#!/usr/bin/env python3
import os
import re
import subprocess

# Paths
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
PUBSPEC_PATH = os.path.join(PROJECT_ROOT, 'pubspec.yaml')
VERSION_DART_PATH = os.path.join(PROJECT_ROOT, 'lib', 'constants', 'version.dart')

def run_command(command):
    try:
        result = subprocess.run(command, shell=True, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print(f"Command failed: {command}")
        print(f"Error: {e.stderr}")
        return None

def get_latest_gh_release_tag():
    # Fetch latest release tag using gh cli
    # Expects gh to be installed and authenticated
    print("Fetching latest release from GitHub...")
    tag = run_command('gh release list --limit 1 --exclude-drafts --exclude-pre-releases')
    if not tag:
        print("No release found or gh command failed.")
        return None
    
    # gh release list output format: TITLE TYPE TAG DATE
    # We need to extract the tag. The output is tab separated usually
    parts = tag.split()
    # Assuming the tag is one of the parts. Usually 3rd column if standard output?
    # Actually `gh release list` default output: Title   Type   Tag   Published
    # Let's try json output for reliability
    tag_json = run_command('gh release list --limit 1 --exclude-drafts --exclude-pre-releases --json tagName')
    if tag_json:
        import json
        try:
            data = json.loads(tag_json)
            if data and len(data) > 0:
                return data[0]['tagName']
        except:
            pass
    return None

def parse_version(version_str):
    # Matches x.y.z+n or v.x.y.z+n, where +n is optional
    match = re.search(r'(\d+)\.(\d+)\.(\d+)(?:\+(\d+))?', version_str)
    if match:
        return {
            'major': int(match.group(1)),
            'minor': int(match.group(2)),
            'patch': int(match.group(3)),
            'build': int(match.group(4)) if match.group(4) else 0
        }
    return None

def read_pubspec_version():
    if not os.path.exists(PUBSPEC_PATH):
        print("pubspec.yaml not found!")
        return None
    
    with open(PUBSPEC_PATH, 'r') as f:
        # Simple line reading to avoid destroying comments with yaml parser
        for line in f:
            if line.strip().startswith('version:'):
                return line.split(':')[1].strip()
    return None

def update_pubspec(new_version):
    with open(PUBSPEC_PATH, 'r') as f:
        lines = f.readlines()
    
    with open(PUBSPEC_PATH, 'w') as f:
        for line in lines:
            if line.strip().startswith('version:'):
                f.write(f'version: {new_version}\n')
            else:
                f.write(line)
    print(f"Updated pubspec.yaml to {new_version}")

def update_dart_constant(version_dict):
    major = version_dict['major']
    minor = version_dict['minor']
    patch = version_dict['patch']
    build = version_dict['build']
    
    version_str = f"{major}.{minor}.{patch}"
    display_str = f"Version {version_str} (Build {build})"
    
    content = f"""// This file is generated by scripts/bump_version.py

const String appVersion = '{display_str}';
const String buildNumber = '{build}';
"""
    with open(VERSION_DART_PATH, 'w') as f:
        f.write(content)
    print(f"Updated lib/constants/version.dart to {display_str}")

def get_total_release_count():
    # Count total releases to determine build number
    print("Counting total releases from GitHub...")
    # Use --limit 2000 to be safe (default is 30)
    # We use --json tagName just to get a list, then count python side or verify text
    output = run_command('gh release list --limit 2000 --json tagName')
    if output:
        import json
        try:
            data = json.loads(output)
            if isinstance(data, list):
                return len(data)
        except:
            pass
    return 0

import argparse

# ... (imports remain)

def get_latest_gh_release_tag():
    # ... (remains same)
    pass # implementation preserved in actual file

# ... (helper functions remain)

def main():
    parser = argparse.ArgumentParser(description='Bump version in pubspec.yaml')
    parser.add_argument('--type', choices=['major', 'minor', 'patch'], default='patch', help='Type of version bump')
    args = parser.parse_args()

    # 1. Get latest GH version for SemVer (Major.Minor.Patch) logic
    latest_tag = get_latest_gh_release_tag()
    
    # 2. Get local pubspec version (fallback)
    local_version_str = read_pubspec_version()
    
    current_version = None
    
    if latest_tag:
        print(f"Latest GitHub Release: {latest_tag}")
        parsed_gh = parse_version(latest_tag)
        if parsed_gh:
            current_version = parsed_gh
        else:
            print("Could not parse GitHub tag version format.")
    
    if not current_version and local_version_str:
        print(f"Using local pubspec version: {local_version_str}")
        current_version = parse_version(local_version_str)
    
    if not current_version:
        print("Could not determine current version. Defaulting to 1.0.0+0")
        current_version = {'major': 1, 'minor': 0, 'patch': 0, 'build': 0}

    # 3. Determine new Build Number
    # Logic: Build Number = Total Release Count + 1
    total_releases = get_total_release_count()
    new_build_number = total_releases + 1
    print(f"Total Releases: {total_releases} -> New Build Number: {new_build_number}")

    # 4. Bump Version based on type
    major = current_version['major']
    minor = current_version['minor']
    patch = current_version['patch']
    
    if args.type == 'major':
        major += 1
        minor = 0
        patch = 0
    elif args.type == 'minor':
        minor += 1
        patch = 0
    else: # patch
        patch += 1
        
    new_version_str = f"{major}.{minor}.{patch}+{new_build_number}"
    
    print(f"Bumping version ({args.type}): {current_version['major']}.{current_version['minor']}.{current_version['patch']} -> {major}.{minor}.{patch} (Build {new_build_number})")
    
    # 5. Update files
    update_pubspec(new_version_str)
    update_dart_constant({
        'major': major,
        'minor': minor,
        'patch': patch,
        'build': new_build_number
    })

if __name__ == "__main__":
    main()
